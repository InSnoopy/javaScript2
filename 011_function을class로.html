<!DOCTYPE html>
<meta charset="UTF-8">
<script>

    // 자바스크립에선 function키워드가 자바의 class키워드 역할까지 같이 한다.

    function Member(name, age, merit){
        this.name = name; // 속성
        this.age = age;
        this.merit = merit;

        /* 메소드를 여기에 선언하면 메모리 낭비가 생긴다.
        this.getName = function(){
            return this.name;
        }
        */

        return this; // 이건 없어도 된다. 명시적 표현(function 키워드가 class의 의미)
    }
    // 자바스크립트를 prototype 언어라고도 불린다. (원래의 형태)
    // 메모리 절약을 위해, 메소드는 공유 ( 속성도 해도 되지만 큰 의미가 없다. )
    // Member에서 생성되는 메서드들은 다 같이 공유한다.
    Member.prototype.getName = function(){
        return this.name;
    }
    // Member.prototype.getAge =()=>this.age // 이건 this를 확실히 가리켜야한다. 화살표 함수의 단점.. 화살표 함수의 this를 쓸땐 주의하자
    Member.prototype.getAge = function(){
        return this.age;
    }




    // console.log(Member.call(document,"박인수", 32, "젊다")); // 연습

    let insoo = new Member("박인수", 32, "젊다"); // 그냥 함수를 부르는게 아니고 앞에 new가 붙는다.
    let chan = new Member("이찬영", 35, "늙었다"); // 그냥 함수를 부르는게 아니고 앞에 new가 붙는다.
    console.log(insoo.getName());
    console.log(insoo.getAge());
    console.log(chan);

    // 기본 타입은 메모리에 부담이 없지만
    // 객체를 넣었더니 메모리가 너무 부족해졌다.
    // 그래서 나온게 복사해서 넘어가니깐 너무 메모리를 먹는다. 참조 방식으로 하자.. 해서 나왔다.


    // 객체를 생성해서 필드값은 값이 다르니깐 상관없지만
    // getName = 메소드인 경우 완전 똑같다. 낭비라고 생각해서 
    // method는 같이 있는걸 좋아하지 않는다. 
    // javascript에서 prototype을 만들어서 getName() 메소드를 공유할 수 있게 해놨다.
    // prototype에 다가 저장한다. 같은 클래스에서 나온 인스턴스는 하나의 prototype에다가 메소드를 정의하고 이걸 공유하게 한다.

    // 우리가 배운 자바도 메소드는 따로 빼논다. 알아서 해준다.
    // javascript는 우리가 직접 해야한다.

    // java도 method는 공유되는 방식으로 되는구나... 몰랐음

</script>
